# Phase 1 Audit — DB and Persistence

**What works well**
- DB lifecycle is explicit: `openDb`/`closeDb` manage the singleton connection and enforce SQLite pragmas (foreign keys, WAL), and `getDb` guards access when not opened. (`src/db/connection.ts`)
- Migrations run in ordered, transactional batches via `runMigrations`, with a `schema_migrations` ledger; the same pattern is mirrored in the test harness for integration tests. (`src/db/migrate.ts`, `tests/helpers/testDb.ts`)
- Verification utilities exercise repo CRUD and lifecycle helpers, providing a basic end-to-end sanity check. (`src/db/verify.ts`)
- Integration tests cover core idempotency and bad-record skipping for offer ingestion, fingerprint-based repost detection, and aggregation persistence/idempotency. (`tests/integration/db/offer_ingestion_idempotency.test.ts`, `tests/integration/db/fingerprint_repost_detection.test.ts`, `tests/integration/db/aggregateCompanyAndPersist.test.ts`)

**Findings**

**High**
- `src/db/connection.ts` `getDb` and `src/ingestion/runOfferBatch.ts` `runOfferBatchIngestion` (also `src/ingestion/pipelines/infojobs.ts` `runInfojobsPipeline`): ingestion paths call repos without ever calling `openDb`, so `getDb()` throws unless the caller remembered to open the DB (or tests inject it). Why it matters: production runs can fail immediately on first DB access, blocking ingestion and persistence. Fix direction: make pipeline entrypoints explicitly own DB lifecycle (open before work, close after), or wrap ingestion in a DB lifecycle helper to enforce initialization.

**Medium**
- `src/ingestion/runLifecycle.ts` `finishRun` (and `createRunAccumulator`) + `src/ingestion/runOfferBatch.ts` `runOfferBatchIngestion` + `src/db/repos/runsRepo.ts` `finishRun`: run counters for `offers_upserted`, `offers_skipped`, `offers_failed`, `offers_duplicates`, and `companies_aggregated`/`companies_failed` are tracked in memory but are never persisted to `ingestion_runs`. The schema includes `companies_aggregated`/`companies_failed` (migration `migrations/0005_add_run_aggregation_counters.sql`), but `finishRun` only writes pages/offers/errors. Why it matters: the run audit trail is incomplete and operational metrics are lost. Fix direction: align `RunCounters`, `IngestionRunUpdate`, and `finishRun` to persist all counters you intend to track, and update `IngestionRun` type accordingly if new columns are authoritative.
- `src/db/repos/companiesRepo.ts` `upsertCompany` and `upsertCompanySource`: upserts are implemented as SELECT-then-INSERT/UPDATE without a transaction and rely on unique indexes (website_domain, normalized_name, provider+provider_company_id). Why it matters: concurrent ingestion can trigger unique-constraint errors or write races, and duplicates can occur for sources without `provider_company_id`. Fix direction: use single-statement UPSERTs where possible, or wrap related steps in a transaction; decide whether a uniqueness constraint is needed for `(company_id, provider)` when provider IDs are missing.
- `src/ingestion/offerPersistence.ts` `persistOffer`: the persistence sequence spans multiple statements (upsert offer → update `last_seen_at` → update canonical fields) without a transaction. Why it matters: partial failures can leave offers without freshness or fingerprint data, which weakens dedupe and freshness logic. Fix direction: group offer upsert + last_seen + canonical updates in a single transaction or add a reconciliation step to backfill missing fields.

**Low**
- `src/db/connection.ts` `getDbPath`/`openDb` and `src/ingestion/offerPersistence.ts` `computeEffectiveSeenAt`: default DB path (`data/app.db`) and SQLite pragmas (`foreign_keys`, `journal_mode`), plus the seen-at policy (updatedAt → publishedAt → now) are hard-coded. Why it matters: environment-specific tuning and policy changes require code edits. Fix direction: move these to a DB constants/config module (e.g., `src/constants/db.ts`) or a runtime configuration layer.
- `src/ingestion/runLifecycle.ts` `finishRun`: integration tests do not assert that `ingestion_runs` rows are finalized or counters persisted; current tests validate ingestion results but not DB run records. Why it matters: regressions in run audit trail can slip through. Fix direction: add integration coverage that inspects `ingestion_runs` after `runOfferBatchIngestion` completes, including status and counters. (Context: `tests/integration/db/offer_ingestion_idempotency.test.ts`)
- `tests/integration/db/fingerprint_repost_detection.test.ts` `it("should compute and persist fingerprint for new canonical offers")` (misuses `getOfferById` from `src/db/repos/offersRepo.ts`): the test passes `result.result.upserted`, but `upserted` is a count, not an offer ID. Why it matters: the test is brittle and only passes because a fresh DB likely assigns ID 1. Fix direction: fetch by `(provider, provider_offer_id)` or query the inserted offer ID directly.
