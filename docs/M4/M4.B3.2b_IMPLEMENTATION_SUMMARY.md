# M4.B3.2b Implementation Summary

## Files Created/Modified

### New Files Created:

1. **src/signal/aggregation/mapCompanyOfferRows.ts**
   - Pure mapping function: `CompanyOfferAggRow[]` → `AggregatableOffer[]`
   - Applies STRONG_THRESHOLD to compute `isStrong` flag
   - Zero side effects, deterministic

2. **src/signal/aggregation/aggregateCompanyAndPersist.ts**
   - Orchestration function: `aggregateCompanyAndPersist(companyId)`
   - End-to-end pipeline: DB query → map → aggregate → persist
   - Returns updated Company record

3. **scripts/smoke-aggregate-company.ts**
   - Smoke test demonstrating BEFORE/AFTER aggregation states
   - Usage: `npx tsx scripts/smoke-aggregate-company.ts <companyId>`

4. **scripts/debug-offers.ts** (bonus)
   - Debug helper to inspect company offers and match state

### Modified Files:

1. **src/signal/aggregation/index.ts**
   - Added exports for `mapCompanyOfferRows` and `aggregateCompanyAndPersist`
   - Pipeline now accessible via `@/signal/aggregation`

## Type Check Status

✅ **PASSED**: `npm run typecheck` completes with no errors

All type contracts correctly wired:

- `CompanyOfferAggRow` (from DB query)
- `AggregatableOffer` (pure function input)
- `CompanyAggregation` (pure function output)
- `CompanyAggregationInput` (DB persistence input)
- `Company` (returned after update)

## Smoke Test Example

```bash
# Run aggregation for company ID 1
npx tsx scripts/smoke-aggregate-company.ts 1
```

### Expected Output Shape:

```
=== M4 Company Aggregation Smoke Test ===
Company ID: 1

--- BEFORE aggregation ---
{
  id: 1,
  name: 'Test Company Updated',
  max_score: null,           # or previous value
  offer_count: null,         # or previous value
  unique_offer_count: null,
  strong_offer_count: null,
  avg_strong_score: null,
  top_category_id: null,
  top_offer_id: null,
  category_max_scores: null,
  last_strong_at: null
}

--- Running aggregateCompanyAndPersist() ---

--- AFTER aggregation ---
{
  id: 1,
  name: 'Test Company Updated',
  max_score: 0,              # computed from canonical offers
  offer_count: 7,            # activity-weighted (1+0 + 1+5 = 7)
  unique_offer_count: 2,     # count of canonical offers
  strong_offer_count: 0,     # canonical offers with score >= 6
  avg_strong_score: null,    # null when no strong offers
  top_category_id: null,     # null when no scored offers
  top_offer_id: 1,           # offer with max score (tie-break: most recent)
  category_max_scores: {},   # empty when no categories matched
  last_strong_at: null       # null when no strong offers
}

✓ Aggregation completed successfully
```

## Alignment with M4 Documentation

### M4.1 (Aggregation Strategy) ✅

**Implemented signals:**

- ✅ `maxScore`: Maximum score across canonical offers
- ✅ `offerCount`: Activity-weighted count (includes reposts via `1 + repostCount`)
- ✅ `uniqueOfferCount`: Count of canonical offers only
- ✅ `strongOfferCount`: Canonical offers with score >= STRONG_THRESHOLD (6)
- ✅ `avgStrongScore`: Simple average (NOT weighted) of strong scores

**Representative category:**

- ✅ `topCategoryId`: Category from offer with maxScore
- ✅ Tie-breaker: Most recent timestamp (publishedAt > updatedAt)

**Explainability:**

- ✅ `topOfferId`: Offer that produced maxScore
- ✅ `categoryMaxScores`: Map of categoryId → maxScore

**No ordering:** ✅ Aggregation is pure computation; ordering handled at query time

### M4.2 (Offer Freshness) ✅

- ✅ **No age-based filtering**: All offers included regardless of age
- ✅ **No time decay**: Scores unchanged by time
- ✅ **Freshness is informational**: `lastStrongAt` provides context only

**Timestamp priority:**

- ✅ `publishedAt` > `updatedAt` > `null`
- ✅ Deterministic timestamp comparison
- ✅ Safe handling of missing dates

### M4.3 (Repost Detection) ✅

**Canonical-only processing:**

- ✅ Only canonical offers (`canonicalOfferId === null`) contribute to metrics
- ✅ Duplicates fully excluded from scoring/counting

**Activity weighting:**

- ✅ `offerCount` uses `sum(1 + repostCount)` to reflect repost activity
- ✅ Exposes both `uniqueOfferCount` (canonical count) and `offerCount` (activity-weighted)

**No invented heuristics:**

- ✅ No filtering beyond canonical check
- ✅ No score adjustments
- ✅ No undocumented business logic

## Implementation Architecture

### Data Flow:

```
DB (offers + matches tables)
  ↓ listCompanyOffersForAggregation()
  ↓ [CompanyOfferAggRow[]]
  ↓
Mapping Layer (mapCompanyOfferRows)
  ↓ [AggregatableOffer[]]
  ↓
Pure Aggregation (aggregateCompany)
  ↓ CompanyAggregation
  ↓
Persistence (updateCompanyAggregation)
  ↓ Company (updated record)
```

### Separation of Concerns:

1. **DB Query** (offersRepo.ts): LEFT JOIN offers+matches, parse JSON
2. **Mapping** (mapCompanyOfferRows.ts): DB format → pure function format
3. **Aggregation** (aggregateCompany.ts): Pure computation, no side effects
4. **Orchestration** (aggregateCompanyAndPersist.ts): Wire it all together
5. **Persistence** (companiesRepo.ts): Atomic update with JSON serialization

### Determinism Guarantees:

- ✅ Pure functions (aggregateCompany, mapCompanyOfferRows)
- ✅ Deterministic SQL ordering (`ORDER BY o.id ASC`)
- ✅ Tie-breaking by timestamp (most recent wins)
- ✅ Safe JSON parsing with fallback (parseTopCategoryId)

## Next Steps

**M4.B3.3** — Integration with ingestion pipeline:

- Call `aggregateCompanyAndPersist()` after offer ingestion
- Batch aggregation for multiple affected companies
- Error handling and retry logic

**M4.B4** — Category summary and explainability:

- Export company rankings with evidence
- Build "why this score" explanations
- Support filtering by category

**M5** — Google Sheets export:

- Export ranked companies to Sheets
- Real-time or scheduled updates
- Gated integration tests
